# Generated by roxytest: do not edit by hand!

# File R/cls_date.R: @tests

test_that("Function class_date_exact() @ L23", {
  expect_error(class_date_exact(), regexp = "@day has too few.*@month has too few.*@year has too few")
  expect_error(class_date_exact(2001), regexp = "@day has too few.*@month has too few")
  expect_error(class_date_exact(2001, 5), regexp = "@day has too few")
  expect_error(class_date_exact(2001, 5, 32), regexp = "Invalid date")
  expect_equal(class_date_exact(2001, 5, 2)@as_val, "2 MAY 2001")
  expect_equal(class_date_exact(28, 7, 12)@as_val, "12 JUL 28")
  expect_equal(class_date_exact(28, 7, 12)@as_date, as.Date("28-07-12"))
})


test_that("Function date_exact_current() @ L66", {
  expect_equal(date_exact_current()@as_date, Sys.Date())
})


test_that("Function class_date_greg() @ L96", {
  expect_error(class_date_greg(), regexp = "@year has too few elements")
  expect_error(class_date_greg(2001, day = 15), regexp = "Day is defined without a month")
  expect_error(class_date_greg(day = 5), regexp = "@year has too few elements")
  expect_error(class_date_greg(month = 10), regexp = "@year has too few elements")
  expect_error(class_date_greg(2010, 13, 3), regexp = "@month has a value which is too high")
  expect_error(class_date_greg(2010, 1, 32), regexp = "@day has a value which is too high")
  expect_error(class_date_greg(320, 5, 16, bce = TRUE), regexp = "BCE date must contain year only")
  expect_equal(class_date_greg(2001, 5, 12)@as_val, "12 MAY 2001")
  expect_equal(class_date_greg(2004, 2, 29)@as_val, "29 FEB 2004")
  expect_equal(class_date_greg(2004, 8)@as_val, "AUG 2004")
  expect_equal(class_date_greg(2012)@as_val, "2012")
  expect_equal(class_date_greg(193, bce = TRUE)@as_val, "193 BCE")
})


test_that("Function class_date_approx() @ L155", {
  expect_error(class_date_approx("hello"), regexp = "@date is in an invalid format")
  expect_equal(class_date_approx(class_date_greg(2001, 5, 12), calc = TRUE)@as_val, 
                                "CAL 12 MAY 2001")
  expect_equal(class_date_approx(class_date_greg(2004, 2, 29), about = TRUE)@as_val, 
                                "ABT 29 FEB 2004")
  expect_equal(class_date_approx(class_date_greg(2004, 8), est = TRUE)@as_val, 
                                 "EST AUG 2004")
})


test_that("Function class_date_period() @ L238", {
  expect_equal(class_date_period()@as_val, "")
  expect_error(class_date_period(""), regexp = "@start_date is in an invalid format")
  expect_error(class_date_period(end_date = ""), regexp = "@end_date is in an invalid format")
  expect_equal(class_date_period("2 JUL 1989")@as_val, "FROM 2 JUL 1989")
  expect_equal(class_date_period(end_date = "2 JUL 1989")@as_val, "TO 2 JUL 1989")
  expect_equal(
    class_date_period(
      start_date = class_date_greg(1995, 6, 1)
    )@as_val, "FROM 1 JUN 1995")
  expect_equal(
    class_date_period(
      end_date = class_date_greg(1995, 6, 1)
    )@as_val, "TO 1 JUN 1995")
  expect_equal(
    class_date_period(
      start_date = class_date_greg(1990, 6, 1),
      end_date = class_date_greg(1995, 3)
    )@as_val, "FROM 1 JUN 1990 TO MAR 1995")
  expect_error(
    class_date_period(
      start_date = class_date_greg(1995, 6, 1),
      end_date = class_date_greg(1995, 6, 1)
    ), regexp = "Start date is the same as end date")
  expect_error(
    class_date_period(
      start_date = class_date_greg(2005, 6, 1),
      end_date = class_date_greg(1995, 6, 1)
    ), regexp = "Start date comes after end date")
  expect_error(
    class_date_period(
      start_date = class_date_greg(2005, 8, 1),
      end_date = class_date_greg(2005, 6, 1)
    ), regexp = "Start date comes after end date")
  expect_error(
    class_date_period(
      start_date = class_date_greg(2005, 8, 10),
      end_date = class_date_greg(2005, 8, 1)
    ), regexp = "Start date comes after end date")
})


test_that("Function class_date_range() @ L321", {
  expect_error(class_date_range(), regexp = "@start_date \\+ @end_date has too few elements")
  expect_error(class_date_range(""), regexp = "@start_date is in an invalid format")
  expect_error(class_date_range(end_date = ""), regexp = "@end_date is in an invalid format")
  expect_equal(class_date_range("2 JUL 1989")@as_val, "AFT 2 JUL 1989")
  expect_equal(class_date_range(end_date = "2 JUL 1989")@as_val, "BEF 2 JUL 1989")
  expect_equal(
    class_date_range(
      start_date = class_date_greg(1995, 6, 1)
    )@as_val, "AFT 1 JUN 1995")
  expect_equal(
    class_date_range(
      end_date = class_date_greg(1995, 6, 1)
    )@as_val, "BEF 1 JUN 1995")
  expect_equal(
    class_date_range(
      start_date = class_date_greg(1990, 6, 1),
      end_date = class_date_greg(1995, 3)
    )@as_val, "BET 1 JUN 1990 AND MAR 1995")
  expect_error(
    class_date_range(
     start_date = class_date_greg(1995, 6, 1),
      end_date = class_date_greg(1995, 6, 1)
    ), regexp = "Start date is the same as end date")
  expect_error(
    class_date_range(
      start_date = class_date_greg(2005, 6, 1),
      end_date = class_date_greg(1995, 6, 1)
    ), regexp = "Start date comes after end date")
  expect_error(
    class_date_range(
      start_date = class_date_greg(2005, 8, 1),
      end_date = class_date_greg(2005, 6, 1)
    ), regexp = "Start date comes after end date")
  expect_error(
    class_date_range(
      start_date = class_date_greg(2005, 8, 10),
      end_date = class_date_greg(2005, 8, 1)
    ), regexp = "Start date comes after end date")
})


test_that("Function class_date_value() @ L364", {
  expect_error(class_date_value("FROM 2016", time = "12:34"), regexp = "A date period should not have a time defined")
  expect_error(class_date_value(class_date_period(end_date = "1980"), time = class_time(3,45,54,6765)), 
               regexp = "A date period should not have a time defined")
  expect_snapshot_value(class_date_value("AFT 1990", date_phrase = "Maybe 1992")@as_ged, "json2")
  expect_snapshot_value(class_date_value("", date_phrase = "Phrase only", time = "02:24")@as_ged, "json2")
})


test_that("Function class_date_sort() @ L417", {
  expect_error(class_date_sort(""), regexp = "@date is in an invalid format")
  expect_error(class_date_sort("FROM 2016"), regexp = "@date is in an invalid format")
  expect_error(class_date_sort(class_date_period(end_date = "1980")), 
               regexp = "@date must be <character> or <gedcomS7::class_date_greg>")
  expect_snapshot_value(class_date_sort("1990", date_phrase = "Maybe 1992")@as_ged, "json2")
})

