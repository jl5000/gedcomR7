---
title: "Referencing records"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Referencing records}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Cross references

All GEDCOM records are given unique identifiers known as xrefs (cross-references) to allow other records to link to them. These are alphanumeric strings surrounded by '@' symbols. The `tidyged` package creates these xrefs automatically:

```{r}
library(tidyged)

simpsons <- gedcom(subm("Me")) |> 
  add_indi(sex = "M") |> 
  add_indi_names(name_pieces(given = "Homer", surname = "Simpson")) |> 
  add_indi(sex = "F") |> 
  add_indi_names(name_pieces(given = "Marge", surname = "Simpson")) |> 
  add_indi(sex = "F") |> 
  add_indi_names(name_pieces(given = "Lisa", surname = "Simpson")) |> 
  add_indi(sex = "M") |>  
  add_indi_names(name_pieces(given = "Bart", surname = "Simpson")) |> 
  add_note("This is a note")

dplyr::filter(simpsons, tag %in% c("INDI", "NOTE")) |> 
  knitr::kable()
```

Note the unique xrefs in the record column.


The property `ged@xref_prefixes` is a named vector containing any alphanumeric string (up to 6 characters long) which will precede the number given to identify new records (of which there are 7 types). This vector must be of a particular length with these specific names.

We'll import a different GEDCOM file which has some records in it:

```{r}
ged_max <- read_gedcom("https://gedcom.io/testfiles/gedcom70/maximal70.ged")

ged_max@xref_prefixes
```

The order that these records appear in the vector will also dictate the order in which records will appear in the exported file.

The `@c_xrefs` property gives a list of record xrefs in the GEDCOM object, split by records type:

```{r}
ged_max@c_xrefs
```

The next xrefs of each type will therefore be:

```{r}
ged_max@c_next_xref
```






## Automating the creation of Individuals and Family Groups

In all the examples you've seen so far the approach has been to build up the tree one record at a time. There are a number of helper functions that allow you to shortcut this laborious exercise. These functions can create multiple records at once, including Family Group records, where you can go back and add more detail. The functions are:

* `add_parents()`
* `add_siblings()`
* `add_spouse()`
* `add_children()`

They all require the xref of an Individual record (or one to be activated), except for `add_children()`, which requires the xref of a Family Group record. These functions do not change the active record. 

Because of this, you cannot use `add_children()` in a single pipeline with the other functions.

The feedback from these functions gives you the necessary xrefs to then add more detail.

To illustrate, we can build up two families starting with a spouse:

```{r}
from_spou <- gedcom(subm("Me")) |>
  add_indi(sex = "M") |>
  add_parents() |>
  add_siblings(sexes = "MMFF") |>
  add_spouse(sex = "F") 
```

The initial individual (@I1@) gets added as a child to a family (@F1@) with two parents (@I2@ and @I3@) and 4 siblings (@I4@ to @I7@). Finally, he is given a spouse (@I8@) in his own family (@F2@).

Now we have the xref of his family, we can add his two daughters:

```{r}
with_chil <- from_spou |>
  add_children(xref = "@F2@", sexes = "FF")
```
Now we have the records, we can use all of these xrefs to add details like names and facts.

The `tidyged.utils` package contains the function `add_ancestors()` to create Individual and Family Group records for entire generations of ancestors.

## A note about unique record identifiers

Record identifiers have been a topic of much discussion in the GEDCOM user community. Even though xref identifiers will be imported unchanged in the `gedcomS7` package, some systems do create their own xref identifiers on import. So you cannot assume they will survive between systems. However, they should always be internally consistent.

For this reason xref identifiers are not supposed to be exposed to the typical user. However this rule can only really be applied to GEDCOM software that has a point-and-click user interface, rather than one that works interactively at the R console (and the `S7` package does not allow you to hide property values). If a `shiny` app is created, then xrefs will be hidden from the user.
